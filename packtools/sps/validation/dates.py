from datetime import datetime, date

from packtools.sps.validation.utils import build_response


def is_subsequence_in_order(subsequence, main_sequence):
    """
    Checks if the elements of 'subsequence' appear in the same main_sequence within 'main_sequence'.

    This function creates an iterator from 'main_sequence' and checks if each item in 'subsequence'
    appears sequentially within this iterator.

    Params:
    -------
    subsequence : list
        A list of elements whose main_sequence needs to be checked.
    main_sequence : list
        A list in which the main_sequence of elements from 'subsequence' will be checked.

    Returns:
    --------
    bool
        True if 'subsequence' is a subsequence of 'main_sequence' maintaining the main_sequence of elements, False otherwise.

    Description automatically generated by ChatGPT.
    """

    # Creates an iterator from the 'main_sequence' list.
    iterator_main_sequence = iter(main_sequence)

    # Checks if each item in 'subsequence' appears in 'iterator_main_sequence' maintaining the main_sequence.
    return all(item in iterator_main_sequence for item in subsequence)


class DateValidation:
    def __init__(self, date_data, params):
        self.params = params
        self.date_data = date_data

    def validate_day_format(self):
        if len(self.date_data.get("day") or "") != 2:
            yield build_response(
                title="day format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="2-digits day",
                obtained=self.date_data.get("day"),
                advice="Provide 2-digits day",
                data=self.date_data,
                error_level=self.params["day_format_error_level"],
            )

    def validate_month_format(self):
        if len(self.date_data.get("month") or "") != 2:
            yield build_response(
                title="month format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="2-digits month",
                obtained=self.date_data.get("month"),
                advice="Provide 2-digits month",
                data=self.date_data,
                error_level=self.params["month_format_error_level"],
            )

    def validate_year_format(self):
        if len(self.date_data.get("year") or "") != 4:
            yield build_response(
                title="year format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="4-digits year",
                obtained=self.date_data.get("year"),
                advice="Provide 4-digits year",
                data=self.date_data,
                error_level=self.params["year_format_error_level"],
            )

    def validate_date(self):
        try:
            _date = date(
                int(self.date_data.get("year")),
                int(self.date_data.get("month") or 1),
                int(self.date_data.get("day") or 1),
            )
            if self.date_data.get("year"):
                yield from self.validate_year_format()
            if self.date_data.get("month"):
                yield from self.validate_month_format()
            if self.date_data.get("day"):
                yield from self.validate_day_format()

        except (ValueError, TypeError) as e:
            yield build_response(
                title="valid date",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="value",
                is_valid=False,
                expected="valid date",
                obtained=self.date_data,
                advice="Provide valid date",
                data=self.date_data,
                error_level=self.params["value_error_level"],
            )

    def validate_complete_date(self):
        if self.date_data["is_complete"]:
            complete_date = self.date_data["display"]

            if limit_date := self.params.get("limit_date"):
                invalid = False
                if self.date_data["type"] in self.params.get("pre_pub_ordered_events"):
                    invalid = complete_date > limit_date
                    advice = f"Provide date <= {limit_date}"
                elif self.date_data["type"] in self.params.get(
                    "pos_pub_ordered_events"
                ):
                    invalid = complete_date <= limit_date
                    advice = f"Provide date > {limit_date}"
                else:
                    invalid = complete_date > limit_date
                    advice = f"Provide date <= {limit_date}"
                if invalid:
                    yield build_response(
                        title="valid date",
                        parent=self.params["parent"],
                        item=self.params["parent"].get("parent"),
                        sub_item=self.date_data["type"],
                        validation_type="value",
                        is_valid=False,
                        expected="valid date",
                        obtained=self.date_data,
                        advice=advice,
                        data=self.date_data,
                        error_level=self.params["limit_error_level"],
                    )
        else:
            yield build_response(
                title=f"{self.date_data['type']} date",
                parent=self.params.get("parent"),
                item=self.params.get("item"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="complete date",
                obtained=self.date_data,
                advice="Provide complete and valid date",
                data=self.date_data,
                error_level=self.params["format_error_level"],
            )


class FulltextDatesValidation:
    """Validates all dates in a Fulltext document according to specific rules.

    This class handles validation of article dates, history dates, and their relationships,
    applying different validation rules for different date types.

    Attributes:
        fulltext_dates: FulltextDates instance containing all document dates
        params: Dictionary containing validation parameters and rules
    """

    def __init__(self, fulltext_dates, params=None):
        """Initialize a FulltextDatesValidation instance.

        Args:
            fulltext_dates: FulltextDates instance to validate
            params: Optional dictionary of validation parameters
        """
        self.fulltext_dates = fulltext_dates
        self.params = params or {}
        self._set_default_params()
        self.params.update(self.params.get(fulltext_dates.fulltext.article_type) or {})
        self.date_types_ordered_by_date = fulltext_dates.date_types_ordered_by_date
        self.date_type_list = (
            self.params["pre_pub_ordered_events"]
            + self.params["pos_pub_ordered_events"]
        )
        if self.params["required_events"]:
            for related_article in self.fulltext_dates.related_articles:
                related_article_type = related_article["related-article-type"]
                if event := self.params["related-article-type"].get(related_article_type):
                    self.params["required_events"].append(event)

    def _set_default_params(self):
        """Set default validation parameters if not provided."""
        self.params.setdefault("day_format_error_level", "CRITICAL")
        self.params.setdefault("month_format_error_level", "CRITICAL")
        self.params.setdefault("year_format_error_level", "CRITICAL")
        self.params.setdefault("format_error_level", "CRITICAL")
        self.params.setdefault("value_error_level", "CRITICAL")
        self.params.setdefault("limit_error_level", "CRITICAL")
        self.params.setdefault("required_events", ["received", "accepted"])
        self.params.setdefault(
            "pre_pub_ordered_events", ["received", "revised", "accepted"]
        )
        self.params.setdefault(
            "pos_pub_ordered_events", ["pub", "corrected", "retracted"]
        )
        self.params.setdefault("parent", {})

    def validate(self):
        """Perform all date validations.

        Yields:
            Generator of validation results for all date checks
        """
        yield from self.validate_article_date()
        yield from self.validate_collection_date()
        yield from self.validate_history_dates()
        yield from self.validate_history_order()
        yield from self.validate_history_events()
        yield from self.validate_translations()
        yield from self.validate_not_translations()

    def validate_translations(self):
        for lang, fulltext_dates in self.fulltext_dates.translations.items():
            validator = FulltextDatesValidation(fulltext_dates, self.params)
            yield from validator.validate()

    def validate_not_translations(self):
        for lang, fulltext_dates in self.fulltext_dates.not_translations.items():
            validator = FulltextDatesValidation(fulltext_dates, self.params)
            yield from validator.validate()

    def validate_article_date(self):
        """Validate the main article date."""
        if article_date := self.fulltext_dates.article_date:
            params = self.params.copy()
            params["limit_date"] = datetime.now().isoformat()[:10]
            validator = DateValidation(article_date, params)
            yield from validator.validate_date()
            yield from validator.validate_complete_date()

    def validate_collection_date(self):
        """Validate the collection date (only basic validation, not completeness)."""
        params = self.params.copy()
        if collection_date := self.fulltext_dates.collection_date:
            validator = DateValidation(collection_date, params)
            yield from validator.validate_date()
            # Note: We don't validate completeness for collection dates

    def validate_history_dates(self):
        """Validate each history date."""
        params = self.params.copy()
        params["limit_date"] = date.now().isoformat()[:10]
        for history_date in self.fulltext_dates.history_dates_list:
            validator = DateValidation(history_date, params)
            yield from validator.validate_date()
            yield from validator.validate_complete_date()

    def get_events_ordered_by_date(self, unordered_events):
        try:
            return sorted(
                unordered_events,
                key=lambda x: (
                    self.date_type_list.index(x)
                    if x in self.date_type_list
                    else float("inf")
                ),
            )
        except ValueError:
            # In case an event in unordered_events is not in self.date_type_list, it's placed at the end of the sorted list
            return unordered_events

    @property
    def missing_events(self):
        return self.get_events_ordered_by_date(
            set(self.params["required_events"]) - set(self.date_types_ordered_by_date),
        )

    @property
    def unexpected_events(self):
        # obtem uma lista em ordem alfabética dos eventos identificados que não são reconhecidos
        return sorted(set(self.date_types_ordered_by_date) - set(self.date_type_list))

    @property
    def is_ordered_history(self):
        # o histórico é válido se os eventos estão ordenados pelo padrão e não há eventos faltantes nem desconhecidos
        return is_subsequence_in_order(
            self.date_types_ordered_by_date, self.date_type_list
        )

    def validate_history_events(self):
        if self.unexpected_events:
            yield build_response(
                title="unexpected events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="value",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Fix date-type or exclude unexpected dates: {self.unexpected_events}",
                data=self.fulltext_dates.history_dates,
                error_level=self.params["unexpected_events_error_level"],
            )

        if self.missing_events:
            yield build_response(
                title="missing events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="value",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Fix date-type or including missing dates: {self.missing_events}",
                data=self.fulltext_dates.history_dates,
                error_level=self.params["missing_events_error_level"],
            )

    def validate_history_order(self):
        """Validate the chronological order of history events."""
        if not self.is_ordered_history:
            expected = self.get_events_ordered_by_date(
                set(self.date_types_ordered_by_date + self.date_type_list)
                - set(self.unexpected_events),
            )
            yield build_response(
                title="ordered events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="match",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Check and fix date and date-type: {self.date_types_ordered_by_date}",
                data=self.fulltext_dates.history_dates,
                error_level=self.params["history_order_error_level"],
            )
