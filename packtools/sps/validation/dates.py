from datetime import datetime, date

from packtools.sps.models.article_dates import HistoryDates
from packtools.sps.models.article_and_subarticles import ArticleAndSubArticles
from packtools.sps.validation.utils import format_response


def date_dict_to_date(date_dict):
    return date(int(date_dict['year']), int(date_dict['month']), int(date_dict['day']))


def _date_is_complete(dict_date, date_element):
    year, month, day = dict_date.get('year') or '', dict_date.get('month') or '', dict_date.get('day') or ''
    try:
        object_date = date(int(dict_date['year']), int(dict_date['month']), int(dict_date['day']))
    except (KeyError, TypeError) as e:
        return False, \
            f'a valid date for {date_element}', \
            '-'.join([year, month, day]), \
            f'{date_element} must be complete', \
            f'Provide {e} of the date'

    except ValueError as e:
        return False, \
            f'a valid date for {date_element}', \
            '-'.join([year, month, day]), \
            f'{date_element} must contain valid values, {e},' if 'invalid literal' in str(
                e) else f'{date_element} must contain valid values', \
            f'Provide valid values for day, month and year'
    else:
        return True, str(object_date), str(object_date), None, None


def is_subsequence_in_order(subsequence, main_sequence):
    """
    Checks if the elements of 'subsequence' appear in the same main_sequence within 'main_sequence'.

    This function creates an iterator from 'main_sequence' and checks if each item in 'subsequence'
    appears sequentially within this iterator.

    Params:
    -------
    subsequence : list
        A list of elements whose main_sequence needs to be checked.
    main_sequence : list
        A list in which the main_sequence of elements from 'subsequence' will be checked.

    Returns:
    --------
    bool
        True if 'subsequence' is a subsequence of 'main_sequence' maintaining the main_sequence of elements, False otherwise.

    Description automatically generated by ChatGPT.
    """

    # Creates an iterator from the 'main_sequence' list.
    iterator_main_sequence = iter(main_sequence)

    # Checks if each item in 'subsequence' appears in 'iterator_main_sequence' maintaining the main_sequence.
    return all(item in iterator_main_sequence for item in subsequence)


def sort_by_reference_list(publication_events, standard_publication_order):
    """
    Sorts 'publication_events' based on the order of elements in 'standard_publication_order'.

    Params:
    -------
    publication_events : list
        The list of publication events to be sorted.
    standard_publication_order : list
        The reference list that defines the desired order of publication events.

    Returns:
    --------
    list
        The sorted list of publication events based on the order of elements in 'standard_publication_order'.

    Description automatically generated by ChatGPT.
    """

    try:
        return sorted(publication_events, key=lambda x: standard_publication_order.index(x) if x in standard_publication_order else float('inf'))
    except ValueError:
        # In case an event in publication_events is not in standard_publication_order, it's placed at the end of the sorted list
        return publication_events


class ArticleDatesValidation:
    def __init__(self, xmltree):
        self.history = HistoryDates(xmltree)
        self.article = ArticleAndSubArticles(xmltree)

    def validate_history_dates(self, order, required_events, error_level=None):
        """
        Checks events in an article's history for completeness, validity, and chronological date main_sequence.

        XML input
        ---------
        <article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
            <front>
                <article-meta>
                    <history>
                        <date date-type="received">
                            <day>05</day>
                            <month>01</month>
                            <year>1998</year>
                        </date>
                        <date date-type="rev-request">
                            <day>14</day>
                            <month>03</month>
                            <year>1998</year>
                        </date>
                        <date date-type="rev-recd">
                            <day>24</day>
                            <month>05</month>
                            <year>1998</year>
                        </date>
                        <date date-type="accepted">
                            <day>06</day>
                            <month>06</month>
                            <year>1998</year>
                        </date>
                        <date date-type="corrected">
                            <day>01</day>
                            <month>06</month>
                            <year>2012</year>
                        </date>
                    </history>
                </article-meta>
            </front>
        </article>

        Parameters
        ----------
        order : list
            A list with the main_sequence in which events occur.
        required_events : list
            A list with required events.
        error_level : str
            Label that defines the criticality of the error.

        Returns
        -------
        list of dict
            A list of dictionaries, such as:
            [
                {
                    'title': 'History date validation',
                    'parent': 'article',
                    'parent_article_type': 'research-article',
                    'parent_id': None,
                    'parent_lang': 'en',
                    'item': 'history',
                    'sub_item': 'date',
                    'validation_type': 'value',
                    'response': 'OK',
                    'expected_value': ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'],
                    'got_value': ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'],
                    'message': "Got ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'], expected ["
                               "'received', 'rev-request', 'rev-recd', 'accepted', 'corrected']",
                    'advice': None,
                    'data': {
                        'article_date': None,
                        'collection_date': None,
                        'history': {
                            'received': {
                                'day': '05',
                                'month': '01',
                                'type': 'received',
                                'year': '1998'
                            },
                            'rev-request': {
                                'day': '14',
                                'month': '03',
                                'type': 'rev-request',
                                'year': '1998'
                            },
                            'rev-recd': {
                                'day': '24',
                                'month': '05',
                                'type': 'rev-recd',
                                'year': '1998'
                            },
                            'accepted': {
                                'day': '06',
                                'month': '06',
                                'type': 'accepted',
                                'year': '1998'
                            },
                            'corrected': {
                                'day': '01',
                                'month': '06',
                                'type': 'corrected',
                                'year': '2012'
                            }
                        },
                        'parent': 'article',
                        'parent_article_type': 'research-article',
                        'parent_id': None,
                        'parent_lang': 'en'
                    },
                }, ...
            ]
        """
        error_level = error_level or "ERROR"
        obtained_events = []

        # obtem os nomes dos eventos e suas respectivas datas
        for item in self.history.history_dates():
            for event_type, event_date in item.get("history").items():
                # verifica se a data é válida
                is_valid, expected, obtained, message, advice = _date_is_complete(event_date, event_type)
                # resposta para data inválida
                if not is_valid:
                    yield format_response(
                        title='History date validation',
                        parent=item.get("parent"),
                        parent_id=item.get("parent_id"),
                        parent_article_type=item.get("parent_article_type"),
                        parent_lang=item.get("parent_lang"),
                        item="history",
                        sub_item="date",
                        validation_type="format",
                        is_valid=is_valid,
                        expected=expected,
                        obtained=obtained,
                        advice=advice,
                        data=item,
                        error_level=error_level,
                    )
                else:
                    # as tuplas (nome do evento, data válida) são introduzidas na lista obtained_events
                    obtained_events.append((event_type, obtained))

            # ordena a lista de eventos de forma cronológica
            ordered_by_date = [tp for tp in sorted(obtained_events, key=lambda x: x[1])]

            # obtem uma lista com os nomes dos eventos ordenados
            ordered_by_event = [event[0] for event in ordered_by_date]

            # obtem uma lista ordenada pelo padrão (order) de eventos requeridos que não foram identificados
            missing_events = sort_by_reference_list(list(set(required_events) - set(ordered_by_event)), order)

            # obtem uma lista em ordem alfabética dos eventos identificados que não são reconhecidos
            unknown_events = sorted(list(set(ordered_by_event) - set(order)))

            # o histórico é válido se os eventos estão ordenados pelo padrão e não há eventos faltantes nem desconhecidos
            is_ordered = is_subsequence_in_order(ordered_by_event, order)
            is_complete = missing_events == []
            are_all_known = unknown_events == []
            is_valid = is_ordered and is_complete and are_all_known

            # prepara o conteúdo de expected que é composto por uma lista com a união dos eventos obtidos e requeridos
            # ordenados pelo padrão
            expected = sort_by_reference_list(
                list((set(ordered_by_event) | set(required_events)) - set(unknown_events)), order)

            # prepara o conteúdo de advice
            advice = 'Provide:'
            if not is_ordered:
                advice += f' the dates of {expected} in chronological order;'
            if not is_complete:
                advice += f' valid date for {missing_events};'
            if not are_all_known:
                advice += f' removal of events {unknown_events};'

            yield format_response(
                    title='History date validation',
                    parent=item.get("parent"),
                    parent_id=item.get("parent_id"),
                    parent_article_type=item.get("parent_article_type"),
                    parent_lang=item.get("parent_lang"),
                    item="history",
                    sub_item="date",
                    validation_type="value",
                    is_valid=is_valid,
                    expected=expected,
                    obtained=ordered_by_event,
                    advice=advice,
                    data=item,
                    error_level=error_level,
            )

    def validate_number_of_digits_in_article_date(self, error_level=None):
        """
        Checks whether date components have the correct number of digits.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>03</day>
                        <month>02</month>
                        <year>2024</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Parameters
        ----------
        error_level : str
            Label that defines the criticality of the error.

        Returns
        -------
        list of dict such as:
            [
                {
                    'title': 'Article pub-date day validation',
                    'parent': 'article',
                    'parent_article_type': 'research-article',
                    'parent_id': None,
                    'parent_lang': 'en',
                    'item': 'pub-date',
                    'sub_item': 'day',
                    'validation_type': 'format',
                    'response': 'OK',
                    'expected_value': '03',
                    'got_value': '03',
                    'message': 'Got 03, expected 03',
                    'advice': None,
                    'data': {'day': '03', 'month': '02', 'type': 'pub', 'year': '2024'},
                }, ...
            ]
        """
        error_level = error_level or "ERROR"

        for elem, expected in zip(('day', 'month', 'year'), (2, 2, 4)):
            value = self.history.article_date.get(elem) or ""
            obtained = len(value)
            validated = obtained == expected
            if value.isdigit():
                expected_value = value.zfill(expected)
            else:
                expected_value = 'a numeric digit for {} represented with {} digits'.format(elem, expected)
                validated = False
            yield format_response(
                title='Article pub-date {} validation'.format(elem),
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item=elem,
                validation_type="format",
                is_valid=validated,
                expected=expected_value,
                obtained=value,
                advice='Provide a {}-digit numeric value for {}'.format(expected, elem),
                data=self.history.article_date,
                error_level=error_level,
            )

    def validate_article_date(self, future_date=None, error_level=None):
        """
        Checks if the publication date is valid and before a deadline.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>01</day>
                        <month>01</month>
                        <year>2023</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Params
        ------
        future_date : str
            A deadline.
        error_level : str
            Label that defines the criticality of the error.

        Returns
        -------
        dict such as:
            {
                'title': 'Article pub-date validation',
                'parent': 'article',
                'parent_article_type': 'research-article',
                'parent_id': None,
                'parent_lang': 'en',
                'item': 'pub-date',
                'sub_item': "@date-type='pub'",
                'validation_type': 'value',
                'response': 'OK',
                'expected_value': 'a date in the format: YYYY-MM-DD before or equal to 2023-12-12',
                'got_value': '2023-01-01',
                'message': 'Got 2023-01-01, expected a date in the format: YYYY-MM-DD before or equal to 2023-12-12',
                'advice': None,
                'data': {'day': '01', 'month': '01', 'type': 'pub', 'year': '2023'},
            }
        """

        future_date = future_date or datetime.now().strftime("%Y-%m-%d")

        error_level = error_level or "ERROR"

        got_value = '-'.join([self.history.article_date.get(elem) for elem in ['year', 'month', 'day']])
        try:
            date_dict_to_date(self.history.article_date)
            validated = got_value <= future_date
        except ValueError as e:
            validated = False

        return format_response(
            title='Article pub-date validation',
            parent="article",
            parent_id=None,
            parent_article_type=self.article.main_article_type,
            parent_lang=self.article.main_lang,
            item="pub-date",
            sub_item="@date-type='pub'",
            validation_type="value",
            is_valid=validated,
            expected='a date in the format: YYYY-MM-DD before or equal to {}'.format(future_date),
            obtained=got_value,
            advice='Provide a date in the format: YYYY-MM-DD before or equal to {}'.format(future_date),
            data=self.history.article_date,
            error_level=error_level,
        )

    def validate_collection_date(self, future_date=None, error_level=None):
        """
        Checks if the collection date exists, is valid and before a deadline.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>01</day>
                        <month>01</month>
                        <year>2023</year>
                    </pub-date>
                    <pub-date date-type="collection" publication-format="electronic">
                        <year>2023</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Params
        ------
        future_date : str
            A deadline.
        error_level : str
            Label that defines the criticality of the error.

        Returns
        -------
        dict such as:
            {
                'title': 'Collection pub-date validation',
                'parent': 'article',
                'parent_article_type': 'research-article',
                'parent_id': None,
                'parent_lang': 'en',
                'item': 'pub-date',
                'sub_item': "@date-type='collection'",
                'validation_type': 'format',
                'response': 'OK',
                'expected_value': '2023',
                'got_value': '2023',
                'message': 'Got 2023, expected 2023',
                'advice': None,
                'data': {'type': 'collection', 'year': '2023'},
            }
        """

        error_level = error_level or "ERROR"

        future_date = future_date or datetime.now().year

        obtained = self.history.collection_date.get("year") if self.history.collection_date else None

        try:
            advice = None
            if not obtained.isdigit():
                advice = 'Provide only numeric values for the collection year'
            elif len(obtained) != 4:
                advice = 'Provide a four-digit numeric value for the year of collection'
            elif int(obtained) > int(future_date):
                advice = 'Provide a numeric value less than or equal to {}'.format(future_date)

            is_valid = advice is None
            expected = obtained if is_valid else "the publication date of the collection"

            return format_response(
                title='Collection pub-date validation',
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item="@date-type='collection'",
                validation_type='format',
                is_valid=is_valid,
                expected=expected,
                obtained=obtained,
                advice=advice,
                data=self.history.collection_date,
                error_level=error_level,
            )
        except AttributeError:
            return format_response(
                title='Collection pub-date validation',
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item="@date-type='collection'",
                validation_type='exist',
                is_valid=False,
                expected='the publication date of the collection',
                obtained=None,
                advice='Provide the publication date of the collection',
                data=self.history.collection_date,
                error_level=error_level,
            )

    def validate(self, data):
        """
        Função que executa as validações da classe ArticleDatesValidation.

        Returns:
            dict: Um dicionário contendo os resultados das validações realizadas.

        """
        dates_req_order_events_results = {
            'article_dates_required_order_events_validation': self.history_dates_are_sorted(
                data['history_dates_required_order'],
                data['required_events'])
        }
        dates_are_complete_results = {
            'article_dates_are_complete_validation': self.history_dates_are_complete()
        }
        dates_req_order_events_results.update(dates_are_complete_results)
        return dates_req_order_events_results
