from datetime import date, datetime

from packtools.sps.models.dates import FulltextDates
from packtools.sps.validation.utils import build_response


def is_subsequence_in_order(subsequence, main_sequence):
    """
    Checks if the elements of 'subsequence' appear in the same main_sequence within 'main_sequence'.

    This function creates an iterator from 'main_sequence' and checks if each item in 'subsequence'
    appears sequentially within this iterator.

    Params:
    -------
    subsequence : list
        A list of elements whose main_sequence needs to be checked.
    main_sequence : list
        A list in which the main_sequence of elements from 'subsequence' will be checked.

    Returns:
    --------
    bool
        True if 'subsequence' is a subsequence of 'main_sequence' maintaining the main_sequence of elements, False otherwise.

    Description automatically generated by ChatGPT.
    """

    # Creates an iterator from the 'main_sequence' list.
    iterator_main_sequence = iter(main_sequence)

    # Checks if each item in 'subsequence' appears in 'iterator_main_sequence' maintaining the main_sequence.
    return all(item in iterator_main_sequence for item in subsequence)


class DateValidation:
    def __init__(self, date_data, params):
        self.params = params
        self.date_data = date_data

    def validate_day_format(self):
        if len(self.date_data.get("day") or "") != 2:
            yield build_response(
                title="day format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="2-digits day",
                obtained=self.date_data.get("day"),
                advice="Provide 2-digits day",
                data=self.date_data,
                error_level=self.params["day_format_error_level"],
            )

    def validate_month_format(self):
        if len(self.date_data.get("month") or "") != 2:
            yield build_response(
                title="month format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="2-digits month",
                obtained=self.date_data.get("month"),
                advice="Provide 2-digits month",
                data=self.date_data,
                error_level=self.params["month_format_error_level"],
            )

    def validate_year_format(self):
        year = self.date_data.get("year") or ""
        if len(year) != 4:
            yield build_response(
                title="year format",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="4-digits year",
                obtained=self.date_data.get("year"),
                advice="Provide 4-digits year",
                data=self.date_data,
                error_level=self.params["year_format_error_level"],
            )

    def validate_year_value(self):
        limit_year = datetime.now().year + 1
        year = self.date_data.get("year") or 0
        if 0 <= int(year) > limit_year:
            yield build_response(
                title="year value",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="value",
                is_valid=False,
                expected="max one year in the future",
                obtained=year,
                advice=f"Provide year {year} < {limit_year}",
                data=self.date_data,
                error_level=self.params["year_value_error_level"],
            )

    def validate_date(self):
        try:
            _date = date(
                int(self.date_data.get("year")),
                int(self.date_data.get("month") or 1),
                int(self.date_data.get("day") or 1),
            )
            if self.date_data.get("year"):
                yield from self.validate_year_format()
                yield from self.validate_year_value()
            if self.date_data.get("month"):
                yield from self.validate_month_format()
            if self.date_data.get("day"):
                yield from self.validate_day_format()

        except (ValueError, TypeError) as e:
            yield build_response(
                title="valid date",
                parent=self.params["parent"],
                item=self.params["parent"].get("parent"),
                sub_item=self.date_data["type"],
                validation_type="value",
                is_valid=False,
                expected="valid date",
                obtained=self.date_data,
                advice="Provide valid date",
                data=self.date_data,
                error_level=self.params["value_error_level"],
            )

    def validate_complete_date(self):
        if self.date_data["is_complete"]:
            complete_date = self.date_data["display"]
            date_type = self.date_data["type"]
            limit_date = self.params["limit_date"]
            pub_date = self.params.get("pub_date")

            invalid = False
            if pub_date:
                if date_type in self.params["pre_pub_ordered_events"]:
                    invalid = complete_date >= pub_date or limit_date
                    advice = f"Provide date ({date_type}: {complete_date}) <= {pub_date or limit_date}"
                elif date_type in self.params["pos_pub_ordered_events"]:
                    invalid = (
                        complete_date < pub_date or complete_date > limit_date
                    )
                    if date_type == "pub":
                        advice = f"Provide date ({date_type}: {complete_date}) < {limit_date}"
                    else:
                        advice = f"Provide date ({date_type}: {complete_date}) > {pub_date}"
            else:
                invalid = complete_date > limit_date
                advice = f"Provide date ({date_type}: {complete_date}) <= {limit_date}"

            if invalid:
                yield build_response(
                    title="valid date",
                    parent=self.params["parent"],
                    item=self.params["parent"].get("parent"),
                    sub_item=self.date_data["type"],
                    validation_type="value",
                    is_valid=False,
                    expected="valid date",
                    obtained=self.date_data,
                    advice=advice,
                    data=self.date_data,
                    error_level=self.params["limit_error_level"],
                )
        else:
            yield build_response(
                title=f"{self.date_data['type']} date",
                parent=self.params.get("parent"),
                item=self.params.get("item"),
                sub_item=self.date_data["type"],
                validation_type="format",
                is_valid=False,
                expected="complete date",
                obtained=self.date_data,
                advice="Provide complete and valid date",
                data=self.date_data,
                error_level=self.params["format_error_level"],
            )


class FulltextDatesValidation:
    """Validates all dates in a Fulltext document according to specific rules.

    This class handles validation of article dates, history dates, and their relationships,
    applying different validation rules for different date types.

    Attributes:
        node: FulltextDates instance containing all document dates
        params: Dictionary containing validation parameters and rules
    """

    def __init__(self, node, params=None):
        """Initialize a FulltextDatesValidation instance.

        Args:
            node: FulltextDates instance to validate
            params: Optional dictionary of validation parameters
        """
        self.fulltext = FulltextDates(node)
        self.params = params or {}

        self._set_default_params()
        self._add_required_events()

        self.date_types_ordered_by_date = (
            self.fulltext.date_types_ordered_by_date
        )
        self.date_type_list = (
            self.params["pre_pub_ordered_events"]
            + self.params["pos_pub_ordered_events"]
        )
        self.params["limit_date"] = datetime.now().isoformat()[:10]
        self.params["pub_date"] = (
            self.fulltext.article_date and self.fulltext.article_date["display"]
        )

    def _set_default_params(self):
        """Set default validation parameters if not provided."""
        self.params.setdefault("day_format_error_level", "CRITICAL")
        self.params.setdefault("month_format_error_level", "CRITICAL")
        self.params.setdefault("year_format_error_level", "CRITICAL")
        self.params.setdefault("format_error_level", "CRITICAL")
        self.params.setdefault("value_error_level", "CRITICAL")
        self.params.setdefault("limit_error_level", "CRITICAL")
        self.params.setdefault("required_events", ["received", "accepted"])
        self.params.setdefault(
            "pre_pub_ordered_events", ["received", "revised", "accepted"]
        )
        self.params.setdefault(
            "pos_pub_ordered_events", ["pub", "corrected", "retracted"]
        )

    def _add_required_events(self):
        self.params.setdefault("required_events", [])
        key = self.fulltext.attribs_parent_prefixed["original_article_type"]
        if event := self.params["required_history_events_for_article_type"].get(
            key
        ):
            self.params["required_events"].append(event)

        for item in self.fulltext.related_articles:
            key = item["related-article-type"]
            if event := self.params[
                "required_history_events_for_related_article_type"
            ].get(key):
                self.params["required_events"].append(event)

    def validate(self):
        """Perform all date validations.

        Yields:
            Generator of validation results for all date checks
        """
        yield from self.validate_article_date()
        yield from self.validate_collection_date()
        yield from self.validate_history_dates()
        yield from self.validate_history_order()
        yield from self.validate_history_events()
        yield from self.validate_translations()
        yield from self.validate_not_translations()

    def validate_translations(self):
        for node in self.fulltext.translations:
            validator = FulltextDatesValidation(node, self.params)
            yield from validator.validate()

    def validate_not_translations(self):
        for node in self.fulltext.not_translations:
            validator = FulltextDatesValidation(node, self.params)
            yield from validator.validate()

    def validate_article_date(self):
        """Validate the main article date."""
        if article_date := self.fulltext.article_date:
            validator = DateValidation(article_date, self.params)
            yield from validator.validate_date()
            yield from validator.validate_complete_date()

    def validate_collection_date(self):
        """Validate the collection date (only basic validation, not completeness)."""
        if collection_date := self.fulltext.collection_date:
            validator = DateValidation(collection_date, self.params)
            yield from validator.validate_date()
            # Note: We don't validate completeness for collection dates

    def validate_history_dates(self):
        """Validate each history date."""
        for history_date in self.fulltext.history_dates_list:
            validator = DateValidation(history_date, self.params)
            yield from validator.validate_date()
            yield from validator.validate_complete_date()

    def get_events_ordered_by_date(self, unordered_events):
        try:
            return sorted(
                unordered_events,
                key=lambda x: (
                    self.date_type_list.index(x)
                    if x in self.date_type_list
                    else float("inf")
                ),
            )
        except ValueError:
            # In case an event in unordered_events is not in self.date_type_list, it's placed at the end of the sorted list
            return unordered_events

    @property
    def missing_events(self):
        return self.get_events_ordered_by_date(
            set(self.params["required_events"])
            - set(self.date_types_ordered_by_date),
        )

    @property
    def unexpected_events(self):
        # obtem uma lista em ordem alfabética dos eventos identificados que não são reconhecidos
        return sorted(
            set(self.date_types_ordered_by_date) - set(self.date_type_list)
        )

    @property
    def is_ordered_history(self):
        # o histórico é válido se os eventos estão ordenados pelo padrão e não há eventos faltantes nem desconhecidos
        return is_subsequence_in_order(
            self.date_types_ordered_by_date, self.date_type_list
        )

    def validate_history_events(self):
        if self.unexpected_events:
            yield build_response(
                title="unexpected events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="value",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Fix date-type or exclude unexpected dates: {self.unexpected_events}",
                data=self.fulltext.history_dates,
                error_level=self.params["unexpected_events_error_level"],
            )

        if self.missing_events:
            yield build_response(
                title="missing events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="value",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Fix date-type or include missing dates: {self.missing_events}",
                data=self.fulltext.history_dates,
                error_level=self.params["missing_events_error_level"],
            )

    def validate_history_order(self):
        """Validate the chronological order of history events."""
        if not self.is_ordered_history:
            expected = self.get_events_ordered_by_date(
                set(self.date_types_ordered_by_date + self.date_type_list)
                - set(self.unexpected_events),
            )
            yield build_response(
                title="ordered events",
                parent=self.params["parent"],
                item="history",
                sub_item=None,
                validation_type="match",
                is_valid=False,
                expected=self.date_type_list,
                obtained=self.date_types_ordered_by_date,
                advice=f"Provide history/dates in chronological order. Fix date and/or date-type",
                data=self.fulltext.history_dates,
                error_level=self.params["history_order_error_level"],
            )
