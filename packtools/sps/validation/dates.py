from datetime import datetime, date

from packtools.sps.models.dates import ArticleDates


def date_dict_to_date(date_dict):
    return date(int(date_dict['year']), int(date_dict['month']), int(date_dict['day']))


def _date_is_complete(dict_date, date_element):
    """
    Checks if a given date dictionary contains a complete and valid date.

    This function attempts to construct a date object from year, month, and day values in 'dict_date'.
    It checks for completeness (all date components are present) and validity (date components form a valid date).

    Params:
    -------
    dict_date : dict
        A dictionary containing 'year', 'month', and 'day' as keys.
    date_element : str
        A string representing the name of the date element being checked, used in error messages.

    Returns:
    -------
    tuple: A tuple containing the following elements:
        - A boolean indicating if the date is complete and valid.
        - A string representation of the expected input format.
        - A string representation of the received date.
        - An error message if the date is incomplete, otherwise None.
        - An error message if the date values are invalid, otherwise None.

    Examples:
    ---------
    1. Valid and complete date:
       result = _date_is_complete({'year': '2020', 'month': '12', 'day': '31'}, 'received')
       print(result)
       # Output: (True, '2020-12-31', '2020-12-31', None, None)

    2. Incomplete date:
       result = _date_is_complete({'year': '2020', 'month': '12'}, 'received')
       print(result)
       # Output: (False, 'a valid date for publication date', '2020-12-', 'publication date must be complete', 'Provide day of the date')

    3. Invalid date values:
       result = _date_is_complete({'year': '2020', 'month': '13', 'day': '31'}, 'received')
       print(result)
       # Output: (False, 'a valid date for publication date', '2020-13-31', 'publication date must contain valid values', 'Provide valid values for day, month and year')

    Comments:
    - The function first initializes year, month, and day to empty strings if they are not present in 'dict_date'.
    - It then tries to create a date object using these values.
    - If any of KeyError, TypeError, or ValueError is raised, the function identifies the type of error (missing or invalid values) and returns appropriate error messages.
    - If the date object is successfully created, it returns True along with the formatted date string.

    Description automatically generated by ChatGPT.
    """
    year, month, day = dict_date.get('year') or '', dict_date.get('month') or '', dict_date.get('day') or ''
    try:
        object_date = date(int(dict_date['year']), int(dict_date['month']), int(dict_date['day']))
    except (KeyError, TypeError) as e:
        return False, \
            f'a valid date for {date_element}', \
            '-'.join([year, month, day]), \
            f'{date_element} must be complete', \
            f'Provide {e} of the date'

    except ValueError as e:
        return False, \
            f'a valid date for {date_element}', \
            '-'.join([year, month, day]), \
            f'{date_element} must contain valid values, {e},' if 'invalid literal' in str(
                e) else f'{date_element} must contain valid values', \
            f'Provide valid values for day, month and year'
    else:
        return True, str(object_date), str(object_date), None, None


def is_subsequence_in_order(subsequence, main_sequence):
    """
    Checks if the elements of 'subsequence' appear in the same main_sequence within 'main_sequence'.

    This function creates an iterator from 'main_sequence' and checks if each item in 'subsequence'
    appears sequentially within this iterator.

    Params:
    -------
    subsequence : list
        A list of elements whose main_sequence needs to be checked.
    main_sequence : list
        A list in which the main_sequence of elements from 'subsequence' will be checked.

    Returns:
    --------
    bool
        True if 'subsequence' is a subsequence of 'main_sequence' maintaining the main_sequence of elements, False otherwise.

    Examples:
    ---------
    1. is_subsequence_in_order(['received', 'rev-recd', 'corrected'], ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'])
       Returns: True
       Explanation: 'received', 'rev-recd' and 'corrected' appear in the same main_sequence in both lists.

    2. is_subsequence_in_order(['rev-recd', 'received', 'corrected'], ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'])
       Returns: False
       Explanation: Even though 'rev-recd', 'received' and 'corrected' are in 'main_sequence', they do not maintain the same main_sequence.

    3. is_subsequence_in_order(['read', 'written', 'edited'], ['received', 'rev-request', 'rev-recd', 'accepted', 'corrected'])
       Returns: False
       Explanation: 'read', 'written' and 'edited' do not appear in 'main_sequence'.

    Description automatically generated by ChatGPT.
    """

    # Creates an iterator from the 'main_sequence' list.
    iterator_main_sequence = iter(main_sequence)

    # Checks if each item in 'subsequence' appears in 'iterator_main_sequence' maintaining the main_sequence.
    return all(item in iterator_main_sequence for item in subsequence)




class ArticleDatesValidation:
    def __init__(self, xmltree):
        self.history = ArticleDates(xmltree)
        self.article_date = ArticleDates(xmltree).article_date
        self.collection_date = ArticleDates(xmltree).collection_date

    def validate_history_dates(self, order, required_events):
        """
        Checks events in an article's history for completeness, validity, and chronological date order.

        XML input
        ---------
        <article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" xml:lang="en">
            <front>
                <article-meta>
                    <history>
                        <date date-type="received">
                            <day>05</day>
                            <month>01</month>
                            <year>1998</year>
                        </date>
                        <date date-type="rev-request">
                            <day>14</day>
                            <month>03</month>
                            <year>1998</year>
                        </date>
                        <date date-type="rev-recd">
                            <day>24</day>
                            <month>05</month>
                            <year>1998</year>
                        </date>
                        <date date-type="accepted">
                            <day>06</day>
                            <month>06</month>
                            <year>1998</year>
                        </date>
                        <date date-type="approved">
                            <day>01</day>
                            <month>06</month>
                            <year>2012</year>
                        </date>
                    </history>
                </article-meta>
            </front>
        </article>

        Parameters
        ----------
        order : list
            A list with the order in which events occur.
        required_events : list
            A list with required events.

        Returns
        -------
        list of dict
            A list of dictionaries, such as:
            [
                {
                    'title': 'History date validation',
                    'xpath': './/front//history//date',
                    'validation_type': 'value',
                    'response': 'OK',
                    'expected_value': ['received', 'rev-request', 'rev-recd', 'accepted', 'approved'],
                    'got_value': ['received', 'rev-request', 'rev-recd', 'accepted', 'approved'],
                    'message': "Got ['received', 'rev-request', 'rev-recd', 'accepted', 'approved'] "
                               "expected ['received', 'rev-request', 'rev-recd', 'accepted', 'approved']",
                    'advice': None
                }, ...
            ]
        """
        seq = []
        for event_type in order:
            event_date = self.history.history_dates_dict.get(event_type)
            if event_date:
                is_valid, expected, obtained, message, advice = _date_is_complete(event_date, event_type)
                if not is_valid:
                    yield {
                        'title': 'History date validation',
                        'xpath': './/front//history//date',
                        'validation_type': 'format',
                        'response': 'ERROR',
                        'expected_value': expected,
                        'got_value': obtained,
                        'message': message,
                        'advice': advice
                    }
                else:
                    seq.append((event_type, obtained))
            elif event_type in required_events:
                yield {
                    'title': 'History date validation',
                    'xpath': './/front//history//date',
                    'validation_type': 'exist',
                    'response': 'ERROR',
                    'expected_value': f'a date for {event_type}',
                    'got_value': None,
                    'message': f'the event {event_type} is required',
                    'advice': f'Provide a valid date for {event_type}'
                }
        seq_ordered = [tp[0] for tp in sorted(seq, key=lambda x: x[1])]
        is_valid = check_order(seq_ordered, order)
        expected = seq_ordered if is_valid else order
        yield {
            'title': 'History date validation',
            'xpath': './/front//history//date',
            'validation_type': 'value',
            'response': 'OK' if is_valid else 'ERROR',
            'expected_value': expected,
            'got_value': seq_ordered,
            'message': f'Got {seq} expected {expected}',
            'advice': None if is_valid else f'Provide a valid sequence of events: {expected}'
        }

    def validate_number_of_digits_in_article_date(self):
        """
        Checks whether date components have the correct number of digits.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>03</day>
                        <month>02</month>
                        <year>2024</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Returns
        -------
        list of dict such as:
            [
                {
                    'title': 'Article pub-date day validation',
                    'xpath': './/front//pub-date[@date-type="pub"]/day',
                    'validation_type': 'format',
                    'response': 'OK',
                    'expected_value': '03',
                    'got_value': '03',
                    'message': 'Got 2 expected 2 numeric digits',
                    'advice': None
                },...
            ]
        """
        result = []
        for elem, expected in zip(('day', 'month', 'year'), (2, 2, 4)):
            value = self.article_date[elem]
            obtained = len(value)
            validated = obtained == expected
            if value.isdigit():
                expected_value = value.zfill(expected)
                message = 'Got {} expected {}'.format(value, expected_value)
            else:
                expected_value = 'A numeric digit for {} represented with {} digits'.format(elem, expected)
                message = 'Got a non-numeric value for {}'.format(elem)
                validated = False
            result.append(
                {
                    'title': 'Article pub-date {} validation'.format(elem),
                    'xpath': './/front//pub-date[@date-type="pub"]/{}'.format(elem),
                    'validation_type': 'format',
                    'response': 'OK' if validated else 'ERROR',
                    'expected_value': expected_value,
                    'got_value': value,
                    'message': message,
                    'advice': None if validated else 'Provide a {}-digit numeric value for {}'.format(expected, elem)
                }
            )
        return result

    def validate_article_date(self, future_date):
        """
        Checks if the publication date is valid and before a deadline.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>01</day>
                        <month>01</month>
                        <year>2023</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Params
        ------
        future_date : str

        Returns
        -------
        dict such as:
            {
                'title': 'Article pub-date validation',
                'xpath': './/front//pub-date[@date-type="pub"]',
                'validation_type': 'value',
                'response': 'OK',
                'expected_value': 'A date in the format: YYYY-MM-DD less than 2023-12-12',
                'got_value': '2023-01-01',
                'message': '2023-01-01 is an valid date',
                'advice': None
            }
        """

        got_value = '-'.join([self.article_date[elem] for elem in ['year', 'month', 'day']])
        try:
            date_dict_to_date(self.article_date)
            validated = got_value <= future_date
        except ValueError as e:
            validated = False

        return {
            'title': 'Article pub-date validation',
            'xpath': './/front//pub-date[@date-type="pub"]',
            'validation_type': 'value',
            'response': 'OK' if validated else 'ERROR',
            'expected_value': 'A date in the format: YYYY-MM-DD before or equal to {}'.format(future_date),
            'got_value': got_value,
            'message': '{} is an {}'.format(got_value, 'valid date' if validated else 'invalid date'),
            'advice': None if validated else 'Provide a date in the format: YYYY-MM-DD before or equal to {}'.format(future_date)
        }

    def validate_collection_date(self, future_date):
        """
        Checks if the collection date exists, is valid and before a deadline.

        XML input
        ---------
        <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"
        article-type="research-article" dtd-version="1.1" specific-use="sps-1.9" xml:lang="en">
            <front>
                <article-meta>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v3">TPg77CCrGj4wcbLCh9vG8bS</article-id>
                    <article-id pub-id-type="publisher-id" specific-use="scielo-v2">S0104-11692020000100303</article-id>
                    <article-id pub-id-type="doi">10.1590/1518-8345.2927.3231</article-id>
                    <article-id pub-id-type="other">00303</article-id>
                    <pub-date date-type="pub" publication-format="electronic">
                        <day>01</day>
                        <month>01</month>
                        <year>2023</year>
                    </pub-date>
                    <pub-date date-type="collection" publication-format="electronic">
                        <year>2023</year>
                    </pub-date>
                </article-meta>
            </front>
        </article>

        Params
        ------
        future_date : str

        Returns
        -------
        list of dict, such as:
            [
                {
                    'title': 'Collection pub-date validation',
                    'xpath': './/front//pub-date[@date-type="collection"]',
                    'validation_type': 'format',
                    'response': 'OK',
                    'expected_value': '2023',
                    'got_value': '2023',
                    'message': 'Got 2023 expected 2023',
                    'advice': None
                }
            ]
        """
        try:
            obtained = self.collection_date.get('year')
            advice = None

            if not obtained.isdigit():
                advice = 'Provide only numeric values for the collection year'
            elif len(obtained) != 4:
                advice = 'Provide a four-digit numeric value for the year of collection'
            elif obtained > future_date:
                advice = 'Provide a numeric value less than or equal to {}'.format(future_date)

            is_valid = advice is None
            expected = obtained if is_valid else "the publication date of the collection"

            yield {
                'title': 'Collection pub-date validation',
                'xpath': './/front//pub-date[@date-type="collection"]',
                'validation_type': 'format',
                'response': 'OK' if is_valid else 'ERROR',
                'expected_value': expected,
                'got_value': obtained,
                'message': 'Got {} expected {}'.format(obtained, expected),
                'advice': advice
            }
        except AttributeError:
            yield {
                'title': 'Collection pub-date validation',
                'xpath': './/front//pub-date[@date-type="collection"]',
                'validation_type': 'exist',
                'response': 'ERROR',
                'expected_value': 'the publication date of the collection',
                'got_value': None,
                'message': 'Got None expected the publication date of the collection',
                'advice': 'Provide the publication date of the collection'
            }


    def validate(self, data):
        """
        Função que executa as validações da classe ArticleDatesValidation.

        Returns:
            dict: Um dicionário contendo os resultados das validações realizadas.
        
        """              
        dates_req_order_events_results = {
                'article_dates_required_order_events_validation': self.history_dates_are_sorted(
                data['history_dates_required_order'], 
                data['required_events'])
            }
        dates_are_complete_results = { 
            'article_dates_are_complete_validation': self.history_dates_are_complete()
            }
        dates_req_order_events_results.update(dates_are_complete_results)
        return dates_req_order_events_results
