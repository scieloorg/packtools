from datetime import datetime, date

from packtools.sps.models.article_dates import HistoryDates
from packtools.sps.models.article_and_subarticles import ArticleAndSubArticles
from packtools.sps.validation.utils import format_response


def date_dict_to_date(date_dict):
    return date(int(date_dict["year"]), int(date_dict["month"]), int(date_dict["day"]))


def _date_is_complete(dict_date, date_element):
    year, month, day = (
        dict_date.get("year") or "",
        dict_date.get("month") or "",
        dict_date.get("day") or "",
    )
    try:
        object_date = date(
            int(dict_date["year"]), int(dict_date["month"]), int(dict_date["day"])
        )
    except (KeyError, TypeError) as e:
        return (
            False,
            f"a valid date for {date_element}",
            "-".join([year, month, day]),
            f"{date_element} must be complete",
            f"Provide {e} of the date",
        )

    except ValueError as e:
        return (
            False,
            f"a valid date for {date_element}",
            "-".join([year, month, day]),
            (
                f"{date_element} must contain valid values, {e},"
                if "invalid literal" in str(e)
                else f"{date_element} must contain valid values"
            ),
            f"Provide valid values for day, month and year",
        )
    else:
        return True, str(object_date), str(object_date), None, None


def is_subsequence_in_order(subsequence, main_sequence):
    """
    Checks if the elements of 'subsequence' appear in the same main_sequence within 'main_sequence'.

    This function creates an iterator from 'main_sequence' and checks if each item in 'subsequence'
    appears sequentially within this iterator.

    Params:
    -------
    subsequence : list
        A list of elements whose main_sequence needs to be checked.
    main_sequence : list
        A list in which the main_sequence of elements from 'subsequence' will be checked.

    Returns:
    --------
    bool
        True if 'subsequence' is a subsequence of 'main_sequence' maintaining the main_sequence of elements, False otherwise.

    Description automatically generated by ChatGPT.
    """

    # Creates an iterator from the 'main_sequence' list.
    iterator_main_sequence = iter(main_sequence)

    # Checks if each item in 'subsequence' appears in 'iterator_main_sequence' maintaining the main_sequence.
    return all(item in iterator_main_sequence for item in subsequence)


def sort_by_reference_list(publication_events, standard_publication_order):
    """
    Sorts 'publication_events' based on the order of elements in 'standard_publication_order'.

    Params:
    -------
    publication_events : list
        The list of publication events to be sorted.
    standard_publication_order : list
        The reference list that defines the desired order of publication events.

    Returns:
    --------
    list
        The sorted list of publication events based on the order of elements in 'standard_publication_order'.

    Description automatically generated by ChatGPT.
    """

    try:
        return sorted(
            publication_events,
            key=lambda x: (
                standard_publication_order.index(x)
                if x in standard_publication_order
                else float("inf")
            ),
        )
    except ValueError:
        # In case an event in publication_events is not in standard_publication_order, it's placed at the end of the sorted list
        return publication_events


class ArticleDatesValidation:
    def __init__(self, xmltree, params=None):
        """Initialize ArticleDatesValidation with XML tree and parameters.

        Args:
            xmltree: XML tree containing the article
            params: Dictionary containing validation parameters:
                - order: List defining standard event order
                - required_events: List of required event types
                - error_level: Error level for validation messages
        """
        self.history = HistoryDates(xmltree)
        self.article = ArticleAndSubArticles(xmltree)
        self.params = params or {
            "order": ["received", "accepted"],
            "required_events": ["received", "accepted"],
            "error_level": "ERROR",
        }

    def validate_history_dates(self):
        """Validate both date formats and event order in history.

        Combines the validation of date formats and event order into
        a single validation process.

        Yields:
            dict: All validation responses for history dates
        """
        # Validate date formats
        yield from self.validate_history_date_formats()

        # Validate event order
        yield from self.validate_history_events_order()

    def validate_history_date_formats(self):
        """Validate the format of each date in the article history.

        Checks if each date in the history is complete and valid according to
        the expected format (year, month, day).

        Yields:
            dict: Validation response for each date's format
        """
        error_level = self.params["error_level"]

        for item in self.history.history_dates():
            for event_type, event_date in item.get("history").items():
                is_valid, expected, obtained, message, advice = _date_is_complete(
                    event_date, event_type
                )

                if not is_valid:
                    yield format_response(
                        title="History date validation",
                        parent=item.get("parent"),
                        parent_id=item.get("parent_id"),
                        parent_article_type=item.get("parent_article_type"),
                        parent_lang=item.get("parent_lang"),
                        item="history",
                        sub_item="date",
                        validation_type="format",
                        is_valid=is_valid,
                        expected=expected,
                        obtained=obtained,
                        advice=advice,
                        data=item,
                        error_level=error_level,
                    )

    def validate_history_events_order(self):
        """Validate the chronological order and completeness of history events.

        Checks if history events are in the correct chronological order,
        all required events are present, and no unknown events exist.

        Yields:
            dict: Validation response for event order and completeness
        """
        error_level = self.params["error_level"]
        order = self.params["order"]
        required_events = self.params["required_events"]

        for item in self.history.history_dates():
            obtained_events = []

            # Collect valid events and their dates
            for event_type, event_date in item.get("history").items():
                is_valid, _, obtained, _, _ = _date_is_complete(event_date, event_type)
                if is_valid:
                    obtained_events.append((event_type, obtained))

            # Sort events chronologically
            ordered_by_date = [tp for tp in sorted(obtained_events, key=lambda x: x[1])]
            ordered_by_event = [event[0] for event in ordered_by_date]

            # Check for missing and unknown events
            missing_events = sort_by_reference_list(
                list(set(required_events) - set(ordered_by_event)), order
            )
            unknown_events = sorted(list(set(ordered_by_event) - set(order)))

            # Validate order and completeness
            is_ordered = is_subsequence_in_order(ordered_by_event, order)
            is_complete = missing_events == []
            are_all_known = unknown_events == []
            is_valid = is_ordered and is_complete and are_all_known

            # Prepare expected event list
            expected = sort_by_reference_list(
                list(
                    (set(ordered_by_event) | set(required_events)) - set(unknown_events)
                ),
                order,
            )

            # Prepare advice based on validation results
            advice = "Provide:"
            if not is_ordered:
                advice += f" the dates of {expected} in chronological order;"
            if not is_complete:
                advice += f" valid date for {missing_events};"
            if not are_all_known:
                advice += f" removal of events {unknown_events};"

            yield format_response(
                title="History date validation",
                parent=item.get("parent"),
                parent_id=item.get("parent_id"),
                parent_article_type=item.get("parent_article_type"),
                parent_lang=item.get("parent_lang"),
                item="history",
                sub_item="date",
                validation_type="value",
                is_valid=is_valid,
                expected=expected,
                obtained=ordered_by_event,
                advice=advice,
                data=item,
                error_level=error_level,
            )

    def validate_number_of_digits_in_article_date(self, error_level=None):
        error_level = error_level or "ERROR"

        for elem, expected in zip(("day", "month", "year"), (2, 2, 4)):
            value = self.history.article_date.get(elem) or ""
            obtained = len(value)
            validated = obtained == expected
            if value.isdigit():
                expected_value = value.zfill(expected)
            else:
                expected_value = (
                    "a numeric digit for {} represented with {} digits".format(
                        elem, expected
                    )
                )
                validated = False
            yield format_response(
                title="Article pub-date {} validation".format(elem),
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item=elem,
                validation_type="format",
                is_valid=validated,
                expected=expected_value,
                obtained=value,
                advice="Provide a {}-digit numeric value for {}".format(expected, elem),
                data=self.history.article_date,
                error_level=error_level,
            )

    def validate_article_date(self, future_date=None, error_level=None):

        future_date = future_date or datetime.now().strftime("%Y-%m-%d")

        error_level = error_level or "ERROR"

        got_value = "-".join(
            [self.history.article_date.get(elem) for elem in ["year", "month", "day"]]
        )
        try:
            date_dict_to_date(self.history.article_date)
            validated = got_value <= future_date
        except ValueError as e:
            validated = False

        return format_response(
            title="Article pub-date validation",
            parent="article",
            parent_id=None,
            parent_article_type=self.article.main_article_type,
            parent_lang=self.article.main_lang,
            item="pub-date",
            sub_item="@date-type='pub'",
            validation_type="value",
            is_valid=validated,
            expected="a date in the format: YYYY-MM-DD before or equal to {}".format(
                future_date
            ),
            obtained=got_value,
            advice="Provide a date in the format: YYYY-MM-DD before or equal to {}".format(
                future_date
            ),
            data=self.history.article_date,
            error_level=error_level,
        )

    def validate_collection_date(self, future_date=None, error_level=None):

        error_level = error_level or "ERROR"

        future_date = future_date or datetime.now().year

        obtained = (
            self.history.collection_date.get("year")
            if self.history.collection_date
            else None
        )

        try:
            advice = None
            if not obtained.isdigit():
                advice = "Provide only numeric values for the collection year"
            elif len(obtained) != 4:
                advice = "Provide a four-digit numeric value for the year of collection"
            elif int(obtained) > int(future_date):
                advice = "Provide a numeric value less than or equal to {}".format(
                    future_date
                )

            is_valid = advice is None
            expected = (
                obtained if is_valid else "the publication date of the collection"
            )

            return format_response(
                title="Collection pub-date validation",
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item="@date-type='collection'",
                validation_type="format",
                is_valid=is_valid,
                expected=expected,
                obtained=obtained,
                advice=advice,
                data=self.history.collection_date,
                error_level=error_level,
            )
        except AttributeError:
            return format_response(
                title="Collection pub-date validation",
                parent="article",
                parent_id=None,
                parent_article_type=self.article.main_article_type,
                parent_lang=self.article.main_lang,
                item="pub-date",
                sub_item="@date-type='collection'",
                validation_type="exist",
                is_valid=False,
                expected="the publication date of the collection",
                obtained=None,
                advice="Provide the publication date of the collection",
                data=self.history.collection_date,
                error_level=error_level,
            )

    def validate(self, data):
        """
        Função que executa as validações da classe ArticleDatesValidation.

        Returns:
            dict: Um dicionário contendo os resultados das validações realizadas.

        """
        dates_req_order_events_results = {
            "article_dates_required_order_events_validation": self.history_dates_are_sorted(
                data["history_dates_required_order"], data["required_events"]
            )
        }
        dates_are_complete_results = {
            "article_dates_are_complete_validation": self.history_dates_are_complete()
        }
        dates_req_order_events_results.update(dates_are_complete_results)
        return dates_req_order_events_results
