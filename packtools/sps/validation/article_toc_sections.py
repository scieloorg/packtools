from packtools.sps.models.article_toc_sections import ArticleTocSections
from packtools.sps.models.article_titles import ArticleTitles


def _get_article_sections(sections):
    """
    Groups article sections by language.

    This function iterates over a collection of article sections, grouping them based on the language specified in each
    section. For each language, a dictionary is created containing a list of sections, a standard title for validating
    the article section title, and a specific xpath.

    Args:
    sections (object): An object containing multiple sections of an article, where each section has a 'lang' attribute
    indicating the language and a 'text' attribute containing the content of the section.

    Returns:
    dict: A dictionary where each key is a language code and the value is another dictionary.
    This dictionary contains a list of sections ('sections') for that language, a standard title ('title'),
    and an xpath ('xpath'). Example:
    {
        'en': {
            'sections': ['English section 1 text'],
            'title': 'Article section title validation',
            'xpath': ".//article-meta//subj-group[@subj-group-type='heading']/subject"
        },
        'fr': {
            'sections': ['French section 1 text'],
            'title': 'Article section title validation',
            'xpath': ".//article-meta//subj-group[@subj-group-type='heading']/subject"
        }
    }


    Description automatically generated by ChatGPT.
    """
    resp = {}
    for section in sections.article_section:
        if section.get('text') is not None:
            lang = section.get('lang')
            if lang not in resp:
                resp[lang] = {}
                resp[lang]['section'] = section.get('text')
                resp[lang]['title'] = 'Article section title validation'
                resp[lang]['xpath'] = ".//article-meta//subj-group[@subj-group-type='heading']/subject"
    return resp


def _get_sub_article_sections(sections):
    """
    Groups article sections by language.

    This function iterates over a collection of sub-article sections, grouping them based on the language specified in each
    section. For each language, a dictionary is created containing a list of sections, a standard title for validating
    the article section title, and a specific xpath.

    Args:
    sections (object): An object containing multiple sections of an article, where each section has a 'lang' attribute
    indicating the language and a 'text' attribute containing the content of the section.

    Returns:
    dict: A dictionary where each key is a language code and the value is another dictionary.
    This dictionary contains a list of sections ('sections') for that language, a standard title ('title'),
    and an xpath ('xpath'). Example:
    {
        'en': {
            'sections': ['English section 1 text'],
            'title': 'Sub-article section title validation',
            'xpath': ".//sub-article[@article-type='translation']//front-stub//subj-group[@subj-group-type='heading']/subject"
        },
        'es': {
            'sections': ['Spanish section 1 text'],
            'title': 'Sub-article section title validation',
            'xpath': ".//sub-article[@article-type='translation']//front-stub//subj-group[@subj-group-type='heading']/subject"
        }
    }


    Description automatically generated by ChatGPT.
    """
    resp = {}
    for section in sections.sub_article_section:
        if section.get('text') is not None:
            lang = section.get('lang')
            if lang not in resp:
                resp[lang] = {}
                resp[lang]['section'] = section.get('text')
                resp[lang]['title'] = f'Sub-article (id={section.get("id")}) section title validation'
                resp[lang]['xpath'] = ".//sub-article[@article-type='translation']//front-stub//subj-group[@subj-group-type='heading']/subject"
    return resp


def _get_sections(sections):
    """
    Aggregates main article sections and sub-article sections into a single dictionary.

    This function first calls `_get_article_sections` to retrieve the main article sections and then `
    _get_sub_article_sections` to get the sub-article sections. Both sets of sections are aggregated into a single
    dictionary, with the sub-article sections being merged into the main article sections.

    Args:
    sections (object): An object containing sections of an article. This object is expected to have a structure that is
    compatible with the `_get_article_sections` and `_get_sub_article_sections` functions.

    Returns:
    dict: A dictionary containing both main article sections and sub-article sections. If a section appears in both
    main and sub-article sections, the version from the sub-article sections will be used. Example:
    {
        'en': {
            'sections': ['Sub English section 1'],  # Overwrites the main article sections
            'title': 'Sub-article section title validation',
            'xpath': ".//sub-article[@article-type='translation']//front-stub//subj-group[@subj-group-type='heading']/subject"
        },
        'fr': {
            'sections': ['Main French section 1'],
            'title': 'Main Article section title validation',
            'xpath': ".//article-meta//subj-group[@subj-group-type='heading']/subject"
        },
        'es': {
            'sections': ['Sub Spanish section 1'],
            'title': 'Sub-article section title validation',
            'xpath': ".//sub-article[@article-type='translation']//front-stub//subj-group[@subj-group-type='heading']/subject"
        }
    }


    Description automatically generated by ChatGPT.
    """
    article = _get_article_sections(sections)
    sub_article = _get_sub_article_sections(sections)
    article.update(sub_article)
    return article


def _create_response(title, xpath, validation, is_valid, expected, obtained_msg, advice):
    return {
                'title': title,
                'xpath': xpath,
                'validation_type': validation,
                'response': 'OK' if is_valid else 'ERROR',
                'expected_value': expected,
                'got_value': obtained_msg,
                'message': 'Got {} expected {}{}'.format(obtained_msg, 'one of ' if expected else '', expected),
                'advice': None if is_valid else advice
            }


class ArticleTocSectionsValidation:
    def __init__(self, xmltree):
        self.xmltree = xmltree
        self.article_toc_sections = ArticleTocSections(xmltree)
        self.article_titles = ArticleTitles(xmltree)

    def validate_article_toc_sections(self, expected_toc_sections):
        """
        Check whether the TOC sections matches the options provided in a standard list.

        XML input
        ---------
        <article xml:lang="es">
        <front>
            <article-meta>
                <title-group>
                    <article-title>Título do artigo em espanhol</article-title>
                </title-group>
                <article-categories>
                    <subj-group subj-group-type="heading">
                        <subject>Nome da seção do artigo em espanhol</subject>
                    </subj-group>
                </article-categories>
            </article-meta>
        </front>
        <sub-article article-type="translation" xml:lang="en">
            <front-stub>
                <article-categories>
                    <subj-group subj-group-type="heading">
                        <subject>Nome da seção do sub-artigo em inglês</subject>
                    </subj-group>
                </article-categories>
                <title-group>
                    <article-title>HEDGING FUTURE CASH FLOWS WITH INTEREST-RATE FUTURES CONTRACTS: A DURATION AND
                     CONVEXITY ANALYSIS UNDER THE NELSON SIEGEL MODEL</article-title>
                </title-group>
            </front-stub>
        </sub-article>
        </article>

        Params
        ------
        expected_toc_sections : dict, such as:
            {
                "es": ["Nome da seção do artigo em espanhol"],
                "en": ["Nome da seção do sub-artigo em inglês"]
            }

        Returns
        -------
        list of dict
            A list of dictionaries, such as:
            [
                {
                'title': 'Article section title validation',
                'xpath': ".//article-meta//subj-group[@subj-group-type='heading']/subject",
                'validation_type': 'match',
                'response': 'OK',
                'expected_value': ['Nome da seção do artigo em espanhol'],
                'got_value': ['Nome da seção do artigo em espanhol'],
                'message': 'Got [\'Nome da seção do artigo em espanhol\'] expected [\'Nome da seção do artigo em espanhol\']',
                'advice': None
                },...
            ]
        """
        obtained_toc_sections = _get_sections(self.article_toc_sections)

        obtained_langs = set(obtained_toc_sections)
        expected_langs = set(expected_toc_sections)
        all_langs = sorted(list(obtained_langs | expected_langs))
        common_langs = sorted(list(obtained_langs & expected_langs))

        if not all_langs:
            title = 'Article or sub-article section title validation'
            xpath = ".//subj-group[@subj-group-type='heading']/subject"
            validation = 'exist'
            yield _create_response(title, xpath, validation, True, None, None, None)

        for lang in all_langs:
            is_valid = False
            title = 'Article or sub-article section title validation'
            xpath = ".//subj-group[@subj-group-type='heading']/subject"
            validation = 'exist'
            expected = expected_toc_sections.get(lang)
            obtained = obtained_toc_sections.get(lang)
            obtained_msg = obtained.get('section') if obtained else None
            advice = 'Provide missing section for language: {}'.format(lang)
            if lang in common_langs:
                if obtained.get('section'):
                    # verifica se todos os títulos de seção estão presentes na lista esperada
                    is_valid = obtained.get('section') in expected
                    title = obtained.get('title')
                    xpath = obtained.get('xpath')
                    validation = 'value in list'
            elif lang in obtained_langs:
                advice = 'Remove {} for language: {}'.format(xpath, lang)

            yield _create_response(title, xpath, validation, is_valid, expected, obtained_msg, advice)

    def validade_article_title_is_different_from_section_titles(self):
        """
        Checks if the titles provided for article and sections are different from each other.

        XML input
        ---------
        <article xml:lang="es">
            <front>
                <article-meta>
                    <title-group>
                        <article-title>Título do artigo em espanhol</article-title>
                            <trans-title-group xml:lang="en">
                                <trans-title>Título do artigo em inglês</trans-title>
                            </trans-title-group>
                    </title-group>
                    <article-categories>
                        <subj-group subj-group-type="heading">
                        <subject>Nome da seção do artigo em espanhol</subject>
                            <subj-group>
                            <subject>Food Safety</subject>
                            </subj-group>
                        </subj-group>
                    </article-categories>
                    <title-group>
                        <article-title>Título do artigo em espanhol</article-title>
                    </title-group>
                </article-meta>
            </front>
            <sub-article article-type="translation" xml:lang="en">
                <front-stub>
                    <article-categories>
                        <subj-group subj-group-type="heading">
                        <subject>Nome da seção do sub-artigo em inglês</subject>
                            <subj-group>
                            <subject>Food Safety</subject>
                            </subj-group>
                        </subj-group>
                    </article-categories>
                    <title-group>
                        <article-title>Título do sub-artigo em inglês</article-title>
                    </title-group>
                </front-stub>
            </sub-article>
        </article>


        Returns
        -------
        list of dict
            A list of dictionaries, such as:
            [
                {
                'title': 'Article section title validation',
                'xpath': ".//article-meta//subj-group[@subj-group-type='heading']/subject",
                'validation_type': 'match',
                'response': 'OK',
                'expected_value': 'article title different from section titles',
                'got_value': 'article title different from section titles',
                'message': "Article title: Título do artigo em espanhol, section titles: ['Nome da seção do artigo em espanhol']",
                'advice': None
                },...
            ]
        """
        obtained_toc_sections = _get_sections(self.article_toc_sections)
        article_title = self.article_titles.article_title_dict

        for lang, sections in obtained_toc_sections.items():
            is_valid = article_title.get(lang) != sections.get('section')
            article = article_title.get(lang)
            section = sections.get('section')
            yield {
                'title': sections.get('title'),
                'xpath': sections.get('xpath'),
                'validation_type': 'match',
                'response': 'OK' if is_valid else 'ERROR',
                'expected_value': '\'{}\' (article title) different from \'{}\' (section titles)'.format(article, section),
                'got_value': 'article title: \'{}\', section titles: \'{}\''.format(article, section),
                'message': 'article and section titles are {}'.format('different' if is_valid else 'the same'),
                'advice': None if is_valid else "Provide different titles for article and section (subj-group[@subj-group-type='heading']/subject)"
            }


    
    def validate(self, data):
        """
        Função que executa as validações da classe ArticleTocSectionsValidation.

        Returns:
            dict: Um dicionário contendo os resultados das validações realizadas.
        
        """
        toc_sections_results = {
            'article_toc_sections_validation': 
                self.validate_article_toc_sections(data['expected_toc_sections'])
            }
        title_results = {
            'article_title_validation': self.validade_article_title_is_different_from_section_titles()
            }
        
        toc_sections_results.update(title_results)
        return toc_sections_results